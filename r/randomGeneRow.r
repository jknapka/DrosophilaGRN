# Generate random and simulated expression data.
if (!exists("util.util",mode="function")) {
    # print("Reading grn_util.r")
    source("r/grn_util.r")
}

# Gene statistics from the real data sets.
geneStats = read.csv('data/geneStats.csv',sep=",",header=TRUE,stringsAsFactors=FALSE)

# Interactions from FlyBase.
interactionList = read.csv('data/interactions-present-in-data.txt',sep=',',header=FALSE,stringsAsFactors=FALSE)

# Number of cell type X region combinations.
CELL_TYPE_REGIONS = 4*5

# Generate a random row of expression data with [replicates] measurements
# for each cell type and region. Choose a gene and for each replicate, select
# a random level from that gene's discretized levels, and then choose a uniform
# random value within the level's corresponding cluster of expression values.
#
# If purelyRandom is TRUE, instead simply choose a value uniformly at random
# between 1 and 1000.
randomGeneRow = function(n,replicates,purelyRandom=F,allZeros=F) {
    result = emptyRow(replicates)

    # First, pick a gene.
    genes = geneStats[,'fbid']
    genes = unique(genes)
    gene = sample(genes,1)
    grows = geneStats[geneStats[,'fbid']==gene,]

    rn = floor(runif(10000,100000000))

    # We have to use the real FBids because we only test the
    # interactions present in the FlyBase interactome.
    fbId = gene
    geneNm = gname(gene)
    cgNum = paste("CG10",as.character(floor(runif(10000))),sep="",collapse="")
    result[1,1] = fbId
    result[1,2] = cgNum
    result[1,3] = geneNm
    
    glevs = grows[,'level']
    # We need 20 replicate-tuples of random samples.
    for (ss in 1:20) {
        for (gss in 1:replicates) {
            expVal = -1
            if (allZeros) {
                expVal = 0.0
            } else if (purelyRandom) {
                # This gives about 5% conserved interactions. Hmmm.
                expVal = runif(1,0.0,1000.0)
            } else {
                # Pick a level.
                glev = sample(glevs,1)
                grow = grows[grows[,'level']==glev,]
                mean = grow[,'mean']
                sdev = grow[,'sd']
                gmin = grow[,'min']
                gmax = grow[,'max']

                # We don't care about this unless the rnorm() below
                # is uncommented. Since there may be very few measurements
                # within any give cluster, it's probably better to choose
                # an expression level uniformly, rather than using any
                # fancier distribution.
                if (is.na(sdev) || is.nan(sdev)) {
                    #print("CHANGING NaN sdev to 0.001")
                    sdev = 0.001
                }

                # Choose an expression level uniformly at random from the
                # measured range of this gene at the chosen level.
                expVal = runif(1,gmin,gmax)

                #expVal = rnorm(1,mean,sdev)
                #if (expVal < 0) expVal = 0
            }

            result[1,replicates*(ss-1)+gss+3] = expVal
        }
    }

    return(result)
}

# Generate a number of random rows.
generateRandomRows <- function(nGenes) {
    geneStats = read.csv('data/geneStats.csv',header=TRUE)

    nGenes = as.numeric(args[1])
    result = emptyRow()
    for (gn in 1:nGenes) {
        rg = randomGeneRow(gn)
        result = rbind(result,rg)
    }

    return(result)
}

fillDataTable <- function(outFile,replicates,purelyRandom=F) {
    tab = read.csv('data/Table-S1.csv')[,1:3]
    tab = fillDataTable_inner(tab,replicates,purelyRandom)
    write.csv(tab,outFile,row.names=FALSE,quote=FALSE)
}

fillDataTable_inner <- function(tab,replicates,purelyRandom=F,allZeros=F) {
    nr = nrow(tab)
    shape = emptyRow(replicates)
    for (col in colnames(shape)[-1:-3]) {
        tab[[col]] = numeric(nr)
    }
    dataCols = grep("^EC|^EE|^EB|^ISC",names(tab))
    for (ss in 1:nrow(tab)) {
        if (allZeros) {
            rr = matrix(rep(0,3+CELL_TYPE_REGIONS*replicates),nrow=1)
        } else {
            rr = randomGeneRow(0,replicates,purelyRandom,allZeros)
        }
        tab[ss,dataCols] = rr[1,-1:-3]
    }
    return(tab)
}

# This injects full data rows generated by some other means,
# eg makeDifferentialRow.py.
injectData <- function(dataFile,outFile,newRowFiles) {
    dat = read.csv(dataFile,sep=",",header=TRUE,stringsAsFactors=FALSE)
    for (rfile in newRowFiles) {
        rows = read.csv(rfile,,sep=",",header=TRUE,stringsAsFactors=FALSE)
        dat[dat[,1]==rows[1,1],-1:-3] = rows[1,-1:-3]
        dat[dat[,1]==rows[2,1],-1:-3] = rows[2,-1:-3]
    }
    write.csv(dat,outFile,row.names=FALSE,quote=FALSE)
}

# This injects simulated data generated here according to a plan
# expressed as a table with the following columns:
#
# cellType: string - EB,EE,EC, or ISC.
# level: integer - the discrete level of the "source" gene involved in the interaction.
# maxlevel: integer - the maximum possible value of level. This is needed because
#    sometimes we won't utilize the entire range of the source gene, and we need
#    to figure out how to map level to the actual source gene's level range.
# tlevel: integer - the discrete level of the "target" gene involved in the interaction.
# maxtlevel: integer - the maximum possible value of tlevel.
# noise: float - the house noise level to apply to tlevel, 0.0 .. 1.0
#
# We choose source and target genes at random, and write the chosen FBids to
# standard output as comma-separated pairs. We then choose a level of the source
# gene at random, and use the taget gene level mapped in the simulation plan for
# the chosen source level. The level and tlevel values
# are mapped into the actual number of quantized levels expressed by the
# selected genes, using maxlevel and maxtlevel to establish the appropriate ranges.
# 
# This is a pretty redundant format, but it's nice for R usage since we
# can easily read it into a data.frame.
#
# Arguments:
#
# * dataFile - name of the data file into which we will inject simulated relationships.
# * outFile - the file to which we will write the result.
# * simFiles - a list of filenames containing simulation plans as described above.
#     Each simulation plan is executed and generates two rows into the original
#     data set: one row for the selected source gene and one for the target gene.
# * withReplacement - If true, all source gene levels are available for sampling
#     each time we need to fill a pair of data cells. If false, a source level is
#     removed from the simulation plan after being chosen, so that other levels
#     are more likely to be chosen subsequently. If all source levels are used,
#     the full simulation plan is re-established and all source levels become
#     available for further data cells.
#
# Result: data.frame of simulated interactions (FBid pairs).
# The data table with simulated regulatory relationships injected is written
# to outFile.
injectData2 <- function(dataFile,outFile,simFiles,withReplacement=T) {
    cat("injectData2\n")
    dat = read.csv(dataFile,sep=",",header=TRUE,stringsAsFactors=FALSE)
    cat("read",dataFile,'\n')

    interactions = data.frame(fbid1=NULL,fbid2=NULL)

    for (sfile in simFiles) {
        simRows = read.csv(sfile,sep=',',header=TRUE,stringsAsFactors=FALSE)
        cat("Processing",sfile,'\n')
        #colnames(simRows) <- c('cellType','level','maxlevel','tlevel','maxtlevel','noise')
        iRow = randomInteraction()
        g1 = iRow[1,1]
        g2 = iRow[1,2]
        cat("inject2 chose random genes",g1,g2,'\n')
        interactions = rbind(interactions,iRow)
        interactions = rbind(interactions,list(g2,g1))
        nreps = floor(ncol(dat))/CELL_TYPE_REGIONS

        # For each cell-type/region/replicate, generate a simulated value.
        for (cellType in c('EC','EE','EB','ISC')) {

            simCtRows = simRows[simRows[,'cellType']==cellType,]
            if (nrow(simCtRows) == 0) {
                simCtRows = simRows[simRows[,'cellType']=='OTHER',]
            }
            print("simCtRows")
            print(simCtRows)
            simCtRowsCopy = data.frame()

            for (region in c('R1','R2','R3','R4','R5')) {
                for (rep in 1:nreps) {
                    # Check if we need to replenish the simulation array.
                    if (nrow(simCtRowsCopy) < 1) {
                        simCtRowsCopy = data.frame(simCtRows)
                    }
                    print("Sampling simulated interaction from")
                    print(simCtRowsCopy)
                    colName = paste(cellType,'_',region,'_',rep,sep='',collapse='')
                    cat("  sampling for column",colName,'\n')
                    sampRow = sample(1:nrow(simCtRows),1)
                    toSimulate = simCtRows[sampRow,]

                    # We can simulate "without replacement" in order to ensure
                    # that all levels of the "source" gene are more likely to
                    # be hit.
                    if (!withReplacement) {
                        simCtRowsCopy = simCtRowsCopy[-sampRow,]
                    }

                    print("toSimulate")
                    print(toSimulate)
                    sLevel = scaleLevel(g1,toSimulate[1,'level'],toSimulate[1,'maxlevel'])
                    tLevel = applyNoise(toSimulate[1,'tlevel'],toSimulate[1,'maxtlevel'],toSimulate[1,'noise'])
                    tLevel = scaleLevel(g2,tLevel,toSimulate[1,'maxtlevel'])
                    cat("    source level",g1,sLevel,"target level",g2,tLevel,'\n')

                    x1 = randomExpression(g1,sLevel)
                    x2 = randomExpression(g2,tLevel)
                    cat("    source expression",x1,"target expression",x2,'\n')
                    dat[dat[,1]==g1,colName] = x1
                    dat[dat[,1]==g2,colName] = x2
                }
            }
        }
    }
     
    write.csv(dat,outFile,row.names=FALSE,quote=FALSE)

    return(interactions)
}

# Scale level in the range 1..max into the corresponding level
# in the actual range of gene gname (actually an FBid).
scaleLevel <- function(gname,level,max) {
    maxGlevel = max(geneStats[geneStats[,'fbid']==gname,'level'])
    result = (round(1+((level-1)/(max-1))*(maxGlevel-1)))
    cat("scaling level",level,"of",max,"by gene",gname,"max level",maxGlevel,'result =',result,'\n')
    return(result)
}

# Compute the probability that level y will move to level y1
# given number of levels Q and noise level theta 0.0 .. 1.0
houseNoise <- function(y,y1,theta,Q) {
    absDiff <-function(d) { return(abs(d-y)) }
    absDiffs = sapply(FUN=absDiff,0:(Q-1))
    if (y != y1) {
        return (( (1.0 - ((abs( y1-y ) )/( sum( absDiffs ) ) ) ) * (theta / (Q-1.0)) ) * (1.0 - theta) + theta/Q)
    } else {
        return (((theta/(Q-1.0)) +1.0 -theta) * (1.0 - theta) + (theta/Q))
    }
}

houseNoiseDistribution <- function(y,Q,theta) {
    noise <- function(y1) {
        return(houseNoise(y,y1,theta,Q))
    }
    return(sapply(FUN=noise,0:(Q-1)))
}

applyNoise <- function(l,Q,theta) {
    cat("applying house noise",theta,"to",l,"of",Q,'\n')
    hnd = houseNoiseDistribution(l-1,Q,theta)
    cat("  distribution:",hnd,'\n')
    result = sample(1:Q,1,prob=hnd)
    cat("  result:",result,'\n')
    return(result)
}

randomGene <- function() {
    genes = unique(geneStats[,1])
    #cat("genes",genes,'\n')
    return(sample(genes,1))
}

randomInteraction <- function() {
    return(interactionList[sample(1:nrow(interactionList),1),])
}

randomLevel <- function(gene) {
    return(sample(geneStats[geneStats[1]==gene,3],1))
}

randomExpression <- function(gene,level=NULL) {
    if (is.null(level)) {
        level = randomLevel(gene)
    }
    #cat("randomExpression gene",gene,"level",level,'\n')
    levelRow = geneStats[geneStats[,1]==gene,]
    levelRow = levelRow[levelRow[,3]==level,]
    #print("randomExpression levelRow")
    #print(levelRow)
    levelMin = levelRow[1,4]
    levelMax = levelRow[1,6]
    cat("choosing random level between",levelMin,"and",levelMax,'\n')
    return(runif(1,levelMin,levelMax))
}

randomizeDataSet <- function(inFile,outFile,replicates=2) {
    cat("Randomizing data set",inFile,"to",outFile,"with",replicates,"relicates.\n")
    in.dat = read.csv(inFile,header=T,stringsAsFactors=F,sep=',')

    cat("Generating background table...\n")
    out.dat = fillDataTable_inner(in.dat,replicates,allZeros=T)

    outNameCols = grep("^EB|^EC|^EE|^ISC",names(out.dat))
    inNameCols = grep("^EB|^EC|^EE|^ISC",names(in.dat))

    # Re-order row labels at random.
    cat("Re-ordering labels...\n")
    in.dat[,1:3] = in.dat[sample(1:nrow(in.dat)),1:3]

    # Re-order each row at random. This preserves the expression profile
    # of each gene, but should destroy all interactions except those
    # which occur at random.
    cat("Generating",nrow(in.dat),"rows...\n")
    for (rr in 1:nrow(in.dat)) {
        out.dat[rr,1:3] = in.dat[rr,1:3]
        out.dat[rr,outNameCols] <- sample(in.dat[rr,inNameCols],length(outNameCols),replace=T)
    }

    cat("Writing result to",outFile,'\n')
    write.csv(out.dat,file=outFile,row.names=F,quote=F)
}

makeSimintFname <- function(fname) {
    pathParts = pathAndName(fname)
    baseDir = paste(pathParts[1],collapse='/',sep='/')
    simintFile = paste(baseDir,'/','simint-',pathParts[2],collapse='',sep='')
}

args <- commandArgs(trailingOnly=TRUE)
print("args")
print(args)
if (length(args) > 0) {
    if ((args[1] == 'gen') || (args[1] == 'rgen')) {
        purelyRandom = (args[1] == 'rgen')
        if (length(args) > 2) {
            replicates = as.numeric(args[3])
        } else {
            replicates = 2
        }
        cat("Generating into",args[2],"\n")
        fillDataTable(args[2],replicates,purelyRandom)
        cat("Done.\n")
    }
    if (args[1] == 'cval') {
        cat("Building randomized data set from existing data.")
        replicates = 2
        if (length(args) > 2) {
            replicates = as.numeric(args[3])
        }
        outFile = args[2]
        inFile = file.path(PROJ_DIR,'data/Table-S1.csv')
        randomizeDataSet(inFile,outFile,replicates=replicates)
    }
    if (args[1] == 'inject') {
        cat("Injecting simulated interactions",args[-1:-3],"into",args[2],"and writing result as",args[3],"\n")
        simulated_interactions = injectData2(args[2],args[3],args[-1:-3])
        simintFile = makeSimintFname(args[3])
        write.table(simulated_interactions,file=simintFile,sep=',',quote=FALSE,col.names=FALSE,row.names=FALSE)
        cat("Done.\n")
    }
}
if (FALSE) {
    print(generateRandomRows(as.numeric(args[1])))
}

